/*******************************************************************************
 * Copyright (c) 2026 Max Oesterle
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *    Max Oesterle - initial API and implementation
 *******************************************************************************/
package tools.vitruv.dsls.vitruvOCL;

import java.io.IOException;
import java.nio.file.Paths;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

/**
 * Utility class providing helper methods for parsing and testing VitruvOCL constraints.
 *
 * <p>This class centralizes common parsing operations used across multiple test classes, providing
 * a consistent interface for parsing OCL constraints from both strings and files. It handles the
 * complete ANTLR parsing pipeline including lexer setup, token stream management, parser
 * configuration, and error handling.
 *
 * <h2>Key Responsibilities</h2>
 *
 * <ul>
 *   <li><b>String parsing:</b> Parse OCL constraints from in-memory strings
 *   <li><b>File parsing:</b> Parse OCL constraints from filesystem {@code .ocl} files
 *   <li><b>Parse tree formatting:</b> Convert parse trees to readable string representations
 *   <li><b>Error handling:</b> Configure consistent error reporting across all parsing operations
 * </ul>
 *
 * <h2>ANTLR Parsing Pipeline</h2>
 *
 * The parsing process follows ANTLR's standard pipeline:
 *
 * <pre>
 * Input (String/File)
 *   ↓
 * CharStream           (ANTLR character stream)
 *   ↓
 * Lexer                (Tokenization - VitruvOCLLexer)
 *   ↓
 * CommonTokenStream    (Token buffer)
 *   ↓
 * Parser               (Parse tree construction - VitruvOCLParser)
 *   ↓
 * ParseTree            (Abstract syntax tree)
 * </pre>
 *
 * <h2>Parser Configuration</h2>
 *
 * All parsing operations use consistent configuration:
 *
 * <ul>
 *   <li><b>Entry point:</b> {@code contextDeclCS()} grammar rule for context declarations
 *   <li><b>Error handling:</b> Custom error listener that throws {@link IllegalStateException} on
 *       syntax errors
 *   <li><b>Error reporting:</b> Includes line number, column position, and error message
 * </ul>
 *
 * <h2>Usage Examples</h2>
 *
 * <pre>{@code
 * // Parse from string
 * ParseTree tree = VitruvOCLParserTestUtils.parseString(
 *     "context spaceMission::Spacecraft inv: self.mass > 0"
 * );
 *
 * // Parse from file
 * ParseTree tree = VitruvOCLParserTestUtils.parseFile(
 *     "test-inputs/valid/simple.ocl"
 * );
 *
 * // Get readable tree representation
 * String treeString = VitruvOCLParserTestUtils.treeToString(tree, parser);
 * System.out.println(treeString);
 * }</pre>
 *
 * <h2>Error Handling Strategy</h2>
 *
 * Parse errors are handled by throwing {@link IllegalStateException} with detailed information:
 *
 * <ul>
 *   <li><b>Location:</b> Line and column of the error
 *   <li><b>Message:</b> ANTLR-generated error description
 *   <li><b>Cause:</b> Original {@link RecognitionException} if available
 * </ul>
 *
 * <p>This fail-fast approach ensures tests immediately detect syntax errors rather than producing
 * invalid parse trees.
 *
 * <h2>Debug Capabilities</h2>
 *
 * The class contains commented-out debug code that can be enabled for troubleshooting:
 *
 * <ul>
 *   <li><b>Input echo:</b> Print the input string being parsed
 *   <li><b>Token stream:</b> Display all tokens generated by the lexer
 *   <li><b>Parse tree:</b> Show raw parse tree structure
 * </ul>
 *
 * <p>To enable debugging, uncomment the relevant {@code System.out.println} statements in the
 * {@link #parse} method.
 *
 * <h2>Design Patterns</h2>
 *
 * This utility class follows several design patterns:
 *
 * <ul>
 *   <li><b>Facade pattern:</b> Simplifies ANTLR's complex API into simple method calls
 *   <li><b>Template method:</b> {@link #parse} provides common parsing logic for string and file
 *       variants
 *   <li><b>Static utility:</b> All methods are static; class is not meant to be instantiated
 * </ul>
 *
 * @author Max
 * @see VitruvOCLLexer ANTLR-generated lexer for tokenization
 * @see VitruvOCLParser ANTLR-generated parser for parse tree construction
 * @see ParseTree ANTLR parse tree interface
 * @see VitruvOCLFileParsingTest Example usage for file-based parsing tests
 */
public class VitruvOCLParserTestUtils {

  /**
   * Parses a VitruvOCL constraint string and returns the parse tree.
   *
   * <p>This method provides a convenient interface for parsing OCL constraints from in-memory
   * strings, commonly used in unit tests where constraints are defined inline.
   *
   * <p><b>Example usage:</b>
   *
   * <pre>{@code
   * String constraint = "context spaceMission::Spacecraft inv: self.mass > 0";
   * ParseTree tree = VitruvOCLParserTestUtils.parseString(constraint);
   * }</pre>
   *
   * <p><b>Input format:</b> The input string should contain a complete OCL context declaration with
   * the standard syntax:
   *
   * <pre>{@code
   * context MetamodelName::ClassName
   * inv [name]: <boolean expression>
   * }</pre>
   *
   * @param input The OCL constraint string to parse
   * @return The ANTLR parse tree representing the parsed constraint
   * @throws IllegalStateException if the input contains syntax errors (thrown by error listener)
   * @see #parseFile For parsing constraints from files
   * @see #parse Core parsing logic shared by string and file parsing
   */
  public static ParseTree parseString(String input) {
    CharStream cs = CharStreams.fromString(input);
    return parse(cs);
  }

  /**
   * Parses a VitruvOCL constraint file and returns the parse tree.
   *
   * <p>This method loads an OCL constraint file from the filesystem and parses it, commonly used in
   * integration tests that validate complete constraint files.
   *
   * <p><b>Example usage:</b>
   *
   * <pre>{@code
   * ParseTree tree = VitruvOCLParserTestUtils.parseFile(
   *     "test-inputs/valid/simple.ocl"
   * );
   * }</pre>
   *
   * <p><b>File path resolution:</b> The fileName parameter is relative to {@code
   * src/test/resources/}. The full path is constructed as {@code src/test/resources/<fileName>}.
   *
   * <p><b>File format:</b> The file should contain a complete OCL context declaration following
   * standard OCL syntax. Example file content:
   *
   * <pre>{@code
   * context spaceMission::Spacecraft
   * inv validMass: self.mass > 0
   *
   * context spaceMission::Mission
   * inv hasSpacecraft: self.spacecraft.size() > 0
   * }</pre>
   *
   * @param fileName Relative path to the OCL file within {@code src/test/resources/}
   * @return The ANTLR parse tree representing the parsed constraint
   * @throws IOException if the file cannot be read from the filesystem
   * @throws IllegalStateException if the file contains syntax errors
   * @see #parseString For parsing constraints from strings
   */
  public static ParseTree parseFile(String fileName) throws IOException {
    String fullPath = "src/test/resources/" + fileName;
    CharStream cs = CharStreams.fromPath(Paths.get(fullPath));
    return parse(cs);
  }

  /**
   * Core parsing method that handles the ANTLR parsing pipeline for any character stream.
   *
   * <p>This private method implements the complete ANTLR parsing process and is called by both
   * {@link #parseString} and {@link #parseFile}. It provides consistent parsing behavior across all
   * input sources.
   *
   * <h3>Parsing Pipeline</h3>
   *
   * <ol>
   *   <li><b>Lexical analysis:</b> {@link VitruvOCLLexer} tokenizes the input character stream
   *   <li><b>Token buffering:</b> {@link CommonTokenStream} provides token lookahead for parser
   *   <li><b>Error handling setup:</b> Custom error listener configured for fail-fast behavior
   *   <li><b>Syntax analysis:</b> {@link VitruvOCLParser} constructs parse tree using {@code
   *       contextDeclCS()} entry point
   * </ol>
   *
   * <h3>Error Handling</h3>
   *
   * The parser is configured with a custom {@link BaseErrorListener} that:
   *
   * <ul>
   *   <li>Removes default ANTLR error listeners (which print to stderr)
   *   <li>Throws {@link IllegalStateException} on any syntax error
   *   <li>Includes detailed error location (line, column) and message
   *   <li>Chains the original {@link RecognitionException} as the cause
   * </ul>
   *
   * <h3>Debug Capabilities</h3>
   *
   * The method contains commented-out debug statements that can be enabled for troubleshooting:
   *
   * <pre>{@code
   * // Uncomment to see input string
   * System.out.println("INPUT STRING: " + cs.toString());
   *
   * // Uncomment to see all tokens
   * tokens.fill();
   * System.out.println("TOKENS:");
   * for (Token t : tokens.getTokens()) {
   *     System.out.println(t.getText() + " [" + t.getType() + "]");
   * }
   *
   * // Uncomment to see parse tree construction
   * System.out.println("Calling parser.contextDeclCS()...");
   * System.out.println("PARSE TREE: " + tree);
   * System.out.println("TREE OBJECT: " + tree.toStringTree(parser));
   * }</pre>
   *
   * <h3>Entry Point</h3>
   *
   * Uses {@code contextDeclCS()} as the grammar entry point, which expects:
   *
   * <pre>{@code
   * context <metamodel>::<class>
   * inv [name]: <expression>
   * }</pre>
   *
   * @param cs ANTLR character stream containing the OCL constraint to parse
   * @return The ANTLR parse tree representing the context declaration
   * @throws IllegalStateException if syntax errors are encountered during parsing
   */
  private static ParseTree parse(CharStream cs) {
    VitruvOCLLexer lexer = new VitruvOCLLexer(cs);
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    VitruvOCLParser parser = new VitruvOCLParser(tokens);

    // Configure error handling: fail fast on syntax errors
    parser.removeErrorListeners();
    parser.addErrorListener(
        new BaseErrorListener() {
          @Override
          public void syntaxError(
              Recognizer<?, ?> recognizer,
              Object offendingSymbol,
              int line,
              int charPositionInLine,
              String msg,
              RecognitionException e) {
            throw new IllegalStateException(
                "Parse error at " + line + ":" + charPositionInLine + " - " + msg, e);
          }
        });

    ParseTree tree = parser.contextDeclCS();
    return tree;
  }

  /**
   * Converts a parse tree to a human-readable string representation.
   *
   * <p>This method provides a formatted view of the parse tree structure, useful for debugging,
   * test output, and understanding how the parser interprets OCL constraints.
   *
   * <p><b>Output format:</b> The string representation uses ANTLR's {@code toStringTree} format,
   * which shows:
   *
   * <ul>
   *   <li>Grammar rule names for non-terminal nodes
   *   <li>Token text for terminal nodes
   *   <li>Nested parentheses showing tree structure
   * </ul>
   *
   * <p><b>Example output:</b>
   *
   * <pre>
   * (contextDeclCS
   *   context
   *   (pathNameCS (firstPathElementCS spaceMission) :: (nextPathElementCS Spacecraft))
   *   inv
   *   :
   *   (expCS (infixedExpCS (prefixedExpCS (primaryExpCS self)) . mass > 0)))
   * </pre>
   *
   * @param tree The parse tree to convert to string format
   * @param parser The parser instance used to create the tree (needed for rule names)
   * @return A formatted string representation of the parse tree showing its hierarchical structure
   * @see ParseTree#toStringTree ANTLR's built-in tree formatting method
   */
  public static String treeToString(ParseTree tree, Parser parser) {
    return tree.toStringTree(parser);
  }
}