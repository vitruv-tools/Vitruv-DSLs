/**
 * generated by Xtext 2.10.0
 */
package tools.vitruv.dsls.reactions.ui.contentassist;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import tools.vitruv.dsls.reactions.language.ModelAttributeChange;
import tools.vitruv.dsls.reactions.language.ModelElementChange;
import tools.vitruv.dsls.reactions.language.toplevelelements.MatchBlock;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsSegment;
import tools.vitruv.dsls.reactions.services.ReactionsLanguageGrammarAccess;

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
@SuppressWarnings("all")
public class ReactionsLanguageProposalProvider extends AbstractReactionsLanguageProposalProvider {
  @Inject
  private ReactionsLanguageGrammarAccess grammarAccess;

  @Override
  public void completeKeyword(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean matchedKeyword = false;
    matchedKeyword = (this.matchInReactionToChangeIn(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchExecuteActionsIn(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchInsertedIn(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchRemovedFrom(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchReplacedAt(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchInsertedAsRoot(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchRemovedAsRoot(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchRetrieve(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchRequireAbsenceOf(keyword, context, acceptor) || matchedKeyword);
    matchedKeyword = (this.matchCorrespondingTo(keyword, context, acceptor) || matchedKeyword);
    if ((!matchedKeyword)) {
      super.completeKeyword(keyword, context, acceptor);
    }
  }

  private boolean matchInReactionToChangeIn(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "in reaction to changes in";
    final String firstKeywordSegment = "in";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ReactionsSegment.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchExecuteActionsIn(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "execute actions in";
    final String firstKeywordSegment = "execute";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ReactionsSegment.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchInsertedIn(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "inserted in";
    final String firstKeywordSegment = "inserted";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ModelAttributeChange.class, ModelElementChange.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchRemovedFrom(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "removed from";
    final String firstKeywordSegment = "removed";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ModelAttributeChange.class, ModelElementChange.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchReplacedAt(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "replaced at";
    final String firstKeywordSegment = "replaced";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ModelAttributeChange.class, ModelElementChange.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchRemovedAsRoot(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "removed as root";
    final String firstKeywordSegment = "removed";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ModelElementChange.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchInsertedAsRoot(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "inserted as root";
    final String firstKeywordSegment = "inserted";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(ModelElementChange.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean matchRetrieve(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final List<String> realKeywords = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList("retrieve", "retrieve optional", "retrieve asserted", "retrieve many"));
    final String firstKeywordSegment = "retrieve";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(MatchBlock.class));
    final Function1<String, Boolean> _function = (String it) -> {
      return Boolean.valueOf(this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, it, relevantContexts));
    };
    return IterableExtensions.<String>forall(realKeywords, _function);
  }

  private boolean matchRequireAbsenceOf(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "require absence of";
    final String firstKeywordSegment = "require";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(MatchBlock.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts, true);
  }

  private boolean matchCorrespondingTo(final Keyword keyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "corresponding to";
    final String firstKeywordSegment = "corresponding";
    final Iterable<Class<?>> relevantContexts = Collections.<Class<?>>unmodifiableList(CollectionLiterals.<Class<?>>newArrayList(MatchBlock.class));
    return this.replaceKeywordIfMatched(keyword, context, acceptor, firstKeywordSegment, realKeyword, relevantContexts);
  }

  private boolean replaceKeywordIfMatched(final Keyword actualKeyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor, final String keywordToMatch, final String replacementKeyword, final Iterable<Class<?>> contextsToMatch) {
    return this.replaceKeywordIfMatched(actualKeyword, context, acceptor, keywordToMatch, replacementKeyword, contextsToMatch, 
      false);
  }

  private boolean replaceKeywordIfMatched(final Keyword actualKeyword, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor, final String keywordToMatch, final String replacementKeyword, final Iterable<Class<?>> contextsToMatch, final boolean recursiveContext) {
    String _value = actualKeyword.getValue();
    boolean _notEquals = (!Objects.equal(_value, keywordToMatch));
    if (_notEquals) {
      return false;
    }
    final ArrayList<EObject> actualContexts = CollectionLiterals.<EObject>newArrayList();
    EObject _currentModel = context.getCurrentModel();
    actualContexts.add(_currentModel);
    if (recursiveContext) {
      while ((IterableExtensions.<EObject>last(actualContexts).eContainer() != null)) {
        EObject _eContainer = IterableExtensions.<EObject>last(actualContexts).eContainer();
        actualContexts.add(_eContainer);
      }
    }
    final Function1<Class<?>, Boolean> _function = (Class<?> matchedContext) -> {
      final Function1<EObject, Boolean> _function_1 = (EObject it) -> {
        return Boolean.valueOf(matchedContext.isInstance(it));
      };
      return Boolean.valueOf(IterableExtensions.<EObject>exists(actualContexts, _function_1));
    };
    boolean _exists = IterableExtensions.<Class<?>>exists(contextsToMatch, _function);
    boolean _not = (!_exists);
    if (_not) {
      return false;
    }
    final ICompletionProposal proposal = this.createCompletionProposal(replacementKeyword, replacementKeyword, 
      this.getImage(this.grammarAccess.getReactionsFileRule()), context);
    this.getPriorityHelper().adjustKeywordPriority(proposal, "top");
    acceptor.accept(proposal);
    return true;
  }

  @Override
  public void completeReactionsImport_UseQualifiedNames(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String realKeyword = "using qualified names";
    final ICompletionProposal proposal = this.createCompletionProposal(realKeyword, realKeyword, 
      this.getImage(this.grammarAccess.getReactionsImportRule()), context);
    this.getPriorityHelper().adjustKeywordPriority(proposal, context.getPrefix());
    acceptor.accept(proposal);
  }
}
