/**
 * generated by Xtext 2.12.0
 */
package tools.vitruv.dsls.commonalities.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import tools.vitruv.dsls.commonalities.language.AttributeMappingOperand;
import tools.vitruv.dsls.commonalities.language.Commonality;
import tools.vitruv.dsls.commonalities.language.CommonalityAttribute;
import tools.vitruv.dsls.commonalities.language.CommonalityAttributeMapping;
import tools.vitruv.dsls.commonalities.language.CommonalityAttributeOperand;
import tools.vitruv.dsls.commonalities.language.CommonalityReference;
import tools.vitruv.dsls.commonalities.language.CommonalityReferenceMapping;
import tools.vitruv.dsls.commonalities.language.LanguagePackage;
import tools.vitruv.dsls.commonalities.language.OperatorAttributeMapping;
import tools.vitruv.dsls.commonalities.language.OperatorReferenceMapping;
import tools.vitruv.dsls.commonalities.language.Participation;
import tools.vitruv.dsls.commonalities.language.ParticipationAttribute;
import tools.vitruv.dsls.commonalities.language.ParticipationAttributeOperand;
import tools.vitruv.dsls.commonalities.language.ParticipationClass;
import tools.vitruv.dsls.commonalities.language.ReferencedParticipationAttributeOperand;
import tools.vitruv.dsls.commonalities.language.SimpleReferenceMapping;
import tools.vitruv.dsls.commonalities.language.elements.Classifier;
import tools.vitruv.dsls.commonalities.language.elements.Metaclass;
import tools.vitruv.dsls.commonalities.language.extensions.CommonalitiesLanguageModelExtensions;
import tools.vitruv.dsls.commonalities.participation.ParticipationContextHelper;
import tools.vitruv.dsls.commonalities.runtime.helper.XtendAssertHelper;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CommonalitiesLanguageValidator extends AbstractCommonalitiesLanguageValidator {
  @Check
  public void checkParticipationClasses(final Participation participation) {
    boolean _isEmpty = IterableExtensions.isEmpty(CommonalitiesLanguageModelExtensions.getAllClasses(participation));
    if (_isEmpty) {
      this.error("Participation is empty.", participation, null);
    } else {
      boolean _isEmpty_1 = IterableExtensions.isEmpty(ParticipationContextHelper.getNonRootClasses(participation));
      if (_isEmpty_1) {
        this.error("Participation has no non-root classes.", participation, null);
      }
    }
  }

  @Check
  public void checkCommonalityFeatureNames(final Commonality commonality) {
    final HashSet<String> attributeNames = new HashSet<String>();
    EList<CommonalityAttribute> _attributes = commonality.getAttributes();
    for (final CommonalityAttribute attribute : _attributes) {
      boolean _add = attributeNames.add(attribute.getName());
      boolean _not = (!_add);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("There is already another attribute or reference with name ‹");
        String _name = attribute.getName();
        _builder.append(_name);
        _builder.append("›.");
        this.error(_builder.toString(), attribute, 
          LanguagePackage.Literals.COMMONALITY_ATTRIBUTE__NAME);
      }
    }
    EList<CommonalityReference> _references = commonality.getReferences();
    for (final CommonalityReference reference : _references) {
      boolean _add_1 = attributeNames.add(reference.getName());
      boolean _not_1 = (!_add_1);
      if (_not_1) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("There is already another attribute or reference with name ‹");
        String _name_1 = reference.getName();
        _builder_1.append(_name_1);
        _builder_1.append("›.");
        this.error(_builder_1.toString(), reference, 
          LanguagePackage.Literals.COMMONALITY_REFERENCE__NAME);
      }
    }
  }

  @Check
  public void checkCommonalityAttributeMappings(final CommonalityAttribute attribute) {
    final HashSet<ParticipationAttribute> readParticipationAttributes = new HashSet<ParticipationAttribute>();
    final Function1<CommonalityAttributeMapping, Boolean> _function = (CommonalityAttributeMapping it) -> {
      return Boolean.valueOf(it.isRead());
    };
    Iterable<CommonalityAttributeMapping> _filter = IterableExtensions.<CommonalityAttributeMapping>filter(attribute.getMappings(), _function);
    for (final CommonalityAttributeMapping mapping : _filter) {
      {
        final ParticipationAttribute participationAttribute = CommonalitiesLanguageModelExtensions.getParticipationAttribute(mapping);
        if ((participationAttribute != null)) {
          boolean _add = readParticipationAttributes.add(participationAttribute);
          boolean _not = (!_add);
          if (_not) {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("There are multiple mappings which read the participation attribute \'");
            _builder.append(participationAttribute);
            _builder.append("\'.");
            this.error(_builder.toString(), 
              LanguagePackage.Literals.COMMONALITY_ATTRIBUTE__MAPPINGS);
          }
        }
      }
    }
  }

  @Check
  public void checkOperatorAttributeMapping(final OperatorAttributeMapping mapping) {
    boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(mapping.getOperator().getQualifiedName());
    if (_isNullOrEmpty) {
      return;
    }
    final Classifier commonalityAttributeType = CommonalitiesLanguageModelExtensions.getCommonalityAttributeType(mapping);
    if ((commonalityAttributeType == null)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Could not find the operator’s declared commonality attribute type ‹");
      String _qualifiedName = mapping.getOperator().getQualifiedName();
      _builder.append(_qualifiedName);
      _builder.append("›.");
      this.error(_builder.toString(), 
        LanguagePackage.Literals.OPERATOR_ATTRIBUTE_MAPPING__OPERATOR);
    }
    final Classifier participationAttributeType = CommonalitiesLanguageModelExtensions.getParticipationAttributeType(mapping);
    if ((participationAttributeType == null)) {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Could not find the operator’s declared participation attribute type ‹");
      String _qualifiedName_1 = mapping.getOperator().getQualifiedName();
      _builder_1.append(_qualifiedName_1);
      _builder_1.append("›.");
      this.error(_builder_1.toString(), 
        LanguagePackage.Literals.OPERATOR_ATTRIBUTE_MAPPING__OPERATOR);
    }
    final int participationAttributeOperandsCount = IterableExtensions.size(CommonalitiesLanguageValidator.getParticipationAttributeOperands(mapping));
    if ((participationAttributeOperandsCount > 1)) {
      this.error("There can only be at most one participation attribute operand.", 
        LanguagePackage.Literals.OPERATOR_ATTRIBUTE_MAPPING__OPERANDS);
    } else {
      if (((participationAttributeOperandsCount == 0) && (IterableExtensions.size(CommonalitiesLanguageModelExtensions.getParticipationClassOperands(mapping)) == 0))) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("Attribute mapping operators need to declare at least one participation attribute or participation ");
        _builder_2.append("class operand.");
        this.error(_builder_2.toString(), LanguagePackage.Literals.OPERATOR_ATTRIBUTE_MAPPING__OPERANDS);
      }
    }
    int _size = CommonalitiesLanguageValidator.getInvolvedParticipations(mapping).size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("The mapping can only refer to participation attributes and classes of a single participation.", 
        LanguagePackage.Literals.OPERATOR_ATTRIBUTE_MAPPING__OPERANDS);
    }
    final CommonalityAttribute commonalityAttribute = CommonalitiesLanguageModelExtensions.getDeclaringAttribute(mapping);
    final Function1<CommonalityAttributeOperand, Boolean> _function = (CommonalityAttributeOperand it) -> {
      CommonalityAttribute _attribute = it.getAttributeReference().getAttribute();
      return Boolean.valueOf(Objects.equal(_attribute, commonalityAttribute));
    };
    boolean _exists = IterableExtensions.<CommonalityAttributeOperand>exists(CommonalitiesLanguageValidator.getCommonalityAttributeOperands(mapping), _function);
    if (_exists) {
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append("The commonality attribute ");
      String _name = commonalityAttribute.getName();
      _builder_3.append(_name);
      _builder_3.append(" cannot be used as operand. It gets ");
      _builder_3.append("implicitly passed to the operator.");
      this.error(_builder_3.toString(), LanguagePackage.Literals.OPERATOR_ATTRIBUTE_MAPPING__OPERANDS);
    }
  }

  private static Iterable<ParticipationAttributeOperand> getParticipationAttributeOperands(final OperatorAttributeMapping mapping) {
    return Iterables.<ParticipationAttributeOperand>filter(mapping.getOperands(), ParticipationAttributeOperand.class);
  }

  private static Set<Participation> getInvolvedParticipations(final OperatorAttributeMapping mapping) {
    final Function1<AttributeMappingOperand, Participation> _function = (AttributeMappingOperand it) -> {
      return CommonalitiesLanguageModelExtensions.getParticipation(it);
    };
    return IterableExtensions.<Participation>toSet(IterableExtensions.<Participation>filterNull(ListExtensions.<AttributeMappingOperand, Participation>map(mapping.getOperands(), _function)));
  }

  private static Iterable<CommonalityAttributeOperand> getCommonalityAttributeOperands(final OperatorAttributeMapping mapping) {
    return Iterables.<CommonalityAttributeOperand>filter(mapping.getOperands(), CommonalityAttributeOperand.class);
  }

  @Check
  public void checkReferenceMapping(final CommonalityReferenceMapping mapping) {
    final Participation participation = CommonalitiesLanguageModelExtensions.getParticipation(mapping);
    if ((participation == null)) {
      return;
    }
    final List<Participation> referencedParticipations = IterableExtensions.<Participation>toList(CommonalitiesLanguageValidator.getReferencedParticipations(mapping));
    int _size = referencedParticipations.size();
    boolean _tripleEquals = (_size == 0);
    if (_tripleEquals) {
      StringConcatenation _builder = new StringConcatenation();
      Commonality _referencedCommonality = CommonalitiesLanguageModelExtensions.getReferencedCommonality(mapping);
      _builder.append(_referencedCommonality);
      _builder.append(" has no participation of domain ");
      String _domainName = participation.getDomainName();
      _builder.append(_domainName);
      _builder.append(".");
      this.error(_builder.toString(), mapping, null);
      return;
    } else {
      int _size_1 = referencedParticipations.size();
      boolean _greaterThan = (_size_1 > 1);
      if (_greaterThan) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Ambiguous reference mapping: ");
        Commonality _referencedCommonality_1 = CommonalitiesLanguageModelExtensions.getReferencedCommonality(mapping);
        _builder_1.append(_referencedCommonality_1);
        _builder_1.append(" has more than one participation of ");
        _builder_1.append("domain ");
        String _domainName_1 = participation.getDomainName();
        _builder_1.append(_domainName_1);
        _builder_1.append(".");
        this.error(_builder_1.toString(), mapping, null);
        return;
      }
    }
    boolean _checkConcreteReferenceMapping = this.checkConcreteReferenceMapping(mapping);
    boolean _not = (!_checkConcreteReferenceMapping);
    if (_not) {
      return;
    }
  }

  private static Iterable<Participation> getReferencedParticipations(final CommonalityReferenceMapping mapping) {
    final String participationDomainName = CommonalitiesLanguageModelExtensions.getParticipation(mapping).getDomainName();
    final Commonality referencedCommonality = CommonalitiesLanguageModelExtensions.getReferencedCommonality(mapping);
    final Function1<Participation, Boolean> _function = (Participation it) -> {
      String _domainName = it.getDomainName();
      return Boolean.valueOf(Objects.equal(_domainName, participationDomainName));
    };
    return IterableExtensions.<Participation>filter(referencedCommonality.getParticipations(), _function);
  }

  private boolean _checkConcreteReferenceMapping(final SimpleReferenceMapping mapping) {
    final Classifier referenceRightType = mapping.getReference().getType();
    if ((!(referenceRightType instanceof Metaclass))) {
      this.error("Reference mappings can only use EReferences.", LanguagePackage.Literals.SIMPLE_REFERENCE_MAPPING__REFERENCE);
      return false;
    }
    final Participation referencedParticipation = CommonalitiesLanguageModelExtensions.getReferencedParticipation(mapping);
    final Iterable<ParticipationClass> nonRootBoundaryClasses = ParticipationContextHelper.getNonRootBoundaryClasses(referencedParticipation);
    boolean _isEmpty = IterableExtensions.isEmpty(nonRootBoundaryClasses);
    boolean _not = (!_isEmpty);
    XtendAssertHelper.assertTrue(_not);
    final Function1<ParticipationClass, Boolean> _function = (ParticipationClass it) -> {
      boolean _isAssignmentCompatible = CommonalitiesLanguageModelExtensions.isAssignmentCompatible(mapping, it);
      return Boolean.valueOf((!_isAssignmentCompatible));
    };
    boolean _isEmpty_1 = IterableExtensions.isEmpty(IterableExtensions.<ParticipationClass>filter(nonRootBoundaryClasses, _function));
    boolean _not_1 = (!_isEmpty_1);
    if (_not_1) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("The referenced classes of participation ‹");
      _builder.append(referencedParticipation);
      _builder.append("› in ");
      Commonality _referencedCommonality = CommonalitiesLanguageModelExtensions.getReferencedCommonality(mapping);
      _builder.append(_referencedCommonality);
      _builder.append(" are not assignment compatible with reference type ");
      _builder.append(referenceRightType);
      _builder.append(".");
      this.error(_builder.toString(), 
        LanguagePackage.Literals.SIMPLE_REFERENCE_MAPPING__REFERENCE);
      return false;
    }
    return true;
  }

  private boolean _checkConcreteReferenceMapping(final OperatorReferenceMapping mapping) {
    boolean _isAttributeReference = CommonalitiesLanguageModelExtensions.isAttributeReference(mapping);
    if (_isAttributeReference) {
      boolean _isEmpty = IterableExtensions.isEmpty(Iterables.<ReferencedParticipationAttributeOperand>filter(mapping.getOperands(), ReferencedParticipationAttributeOperand.class));
      if (_isEmpty) {
        this.error("No referenced participation attribute specified.", LanguagePackage.Literals.OPERATOR_REFERENCE_MAPPING__OPERANDS);
        return false;
      }
      final Participation referencedParticipation = CommonalitiesLanguageModelExtensions.getReferencedParticipation(mapping);
      boolean _isEmpty_1 = ParticipationContextHelper.getParticipationContext(referencedParticipation).isEmpty();
      if (_isEmpty_1) {
        this.error("The referenced participation specifies no root context.", mapping, null);
        return false;
      }
    }
    return true;
  }

  @Check
  public void checkParticipationClassSuperclassIsNotAbstract(final ParticipationClass participationClass) {
    if (((participationClass.getSuperMetaclass() != null) && participationClass.getSuperMetaclass().isAbstract())) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Abstract classes cannot be used as participations.");
      this.error(_builder.toString(), LanguagePackage.Literals.PARTICIPATION_CLASS__SUPER_METACLASS);
    }
  }

  /**
   * Participations can only contain a single Resource class.
   * <p>
   * If the participation has a Resource class, it is required to be the only
   * root container class.
   * <p>
   * Note: If the participation does not specify any Resource root container,
   * it either relies on external commonality reference mappings to specify a
   * root container for it, or it is a commonality participation whose
   * classes are implicitly contained inside the intermediate model's root.
   * In these cases, the participation is allowed to have multiple root
   * classes.
   */
  @Check
  public void checkParticipationHasSingleResourceRoot(final Participation participation) {
    final Set<ParticipationClass> resourceClasses = IterableExtensions.<ParticipationClass>toSet(CommonalitiesLanguageValidator.getResourceClasses(participation));
    int _size = resourceClasses.size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Participations can only contain a single Resource class.");
      this.error(_builder.toString(), participation, null);
    } else {
      if (((resourceClasses.size() == 1) && (!Objects.equal(resourceClasses, CommonalitiesLanguageModelExtensions.getRootContainerClasses(participation))))) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("The Resource class has to be the (only) root class.");
        this.error(_builder_1.toString(), participation, null);
      }
    }
  }

  private static Iterable<ParticipationClass> getResourceClasses(final Participation participation) {
    final Function1<ParticipationClass, Boolean> _function = (ParticipationClass it) -> {
      return Boolean.valueOf(CommonalitiesLanguageModelExtensions.isForResource(it));
    };
    return IterableExtensions.<ParticipationClass>filter(CommonalitiesLanguageModelExtensions.getAllClasses(participation), _function);
  }

  @Check
  public void checkSingleton(final Participation participation) {
    final int numberOfSingletons = IterableExtensions.size(CommonalitiesLanguageValidator.getSingletonClasses(participation));
    if ((numberOfSingletons == 0)) {
      return;
    }
    if ((numberOfSingletons > 1)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Participations can only contain a single singleton class.");
      this.error(_builder.toString(), participation, null);
    } else {
      boolean _hasResourceClass = CommonalitiesLanguageModelExtensions.hasResourceClass(participation);
      boolean _not = (!_hasResourceClass);
      if (_not) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Participations with a singleton class marked need to specify a Resource root.");
        this.error(_builder_1.toString(), participation, null);
      }
      final ParticipationClass singletonClass = CommonalitiesLanguageModelExtensions.getSingletonClass(participation);
      final Iterable<ParticipationClass> singletonContainers = CommonalitiesLanguageModelExtensions.getTransitiveContainerClasses(singletonClass);
      final Function1<ParticipationClass, Boolean> _function = (ParticipationClass it) -> {
        int _size = IterableExtensions.size(CommonalitiesLanguageModelExtensions.getContainedClasses(it));
        return Boolean.valueOf((_size > 1));
      };
      boolean _exists = IterableExtensions.<ParticipationClass>exists(singletonContainers, _function);
      if (_exists) {
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("The containers of the singleton class need to form a containment chain (contain each at most ");
        _builder_2.append("one object).");
        this.error(_builder_2.toString(), participation, null);
      }
    }
  }

  private static Iterable<ParticipationClass> getSingletonClasses(final Participation participation) {
    final Function1<ParticipationClass, Boolean> _function = (ParticipationClass it) -> {
      return Boolean.valueOf(it.isSingleton());
    };
    return IterableExtensions.<ParticipationClass>filter(CommonalitiesLanguageModelExtensions.getAllClasses(participation), _function);
  }

  private boolean checkConcreteReferenceMapping(final CommonalityReferenceMapping mapping) {
    if (mapping instanceof OperatorReferenceMapping) {
      return _checkConcreteReferenceMapping((OperatorReferenceMapping)mapping);
    } else if (mapping instanceof SimpleReferenceMapping) {
      return _checkConcreteReferenceMapping((SimpleReferenceMapping)mapping);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(mapping).toString());
    }
  }
}
