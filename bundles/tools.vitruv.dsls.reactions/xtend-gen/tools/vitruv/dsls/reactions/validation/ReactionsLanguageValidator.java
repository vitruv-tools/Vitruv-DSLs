/**
 * generated by Xtext 2.9.0
 */
package tools.vitruv.dsls.reactions.validation;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import tools.vitruv.dsls.common.elements.ElementsPackage;
import tools.vitruv.dsls.common.elements.MetaclassEReferenceReference;
import tools.vitruv.dsls.common.elements.MetaclassReference;
import tools.vitruv.dsls.common.elements.NamedMetaclassReference;
import tools.vitruv.dsls.reactions.codegen.helper.ReactionsElementsCompletionChecker;
import tools.vitruv.dsls.reactions.codegen.helper.ReactionsImportsHelper;
import tools.vitruv.dsls.reactions.codegen.helper.ReactionsLanguageHelper;
import tools.vitruv.dsls.reactions.language.ElementChangeType;
import tools.vitruv.dsls.reactions.language.ElementInsertionInListChangeType;
import tools.vitruv.dsls.reactions.language.ElementReferenceChangeType;
import tools.vitruv.dsls.reactions.language.ElementRemovalFromListChangeType;
import tools.vitruv.dsls.reactions.language.LanguagePackage;
import tools.vitruv.dsls.reactions.language.ModelElementChange;
import tools.vitruv.dsls.reactions.language.RetrieveModelElement;
import tools.vitruv.dsls.reactions.language.toplevelelements.CreateBlock;
import tools.vitruv.dsls.reactions.language.toplevelelements.NamedJavaElementReference;
import tools.vitruv.dsls.reactions.language.toplevelelements.Reaction;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsFile;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsImport;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsSegment;
import tools.vitruv.dsls.reactions.language.toplevelelements.Routine;
import tools.vitruv.dsls.reactions.language.toplevelelements.TopLevelElementsPackage;
import tools.vitruv.dsls.reactions.runtime.structure.ReactionsImportPath;
import tools.vitruv.dsls.reactions.scoping.ReactionsImportScopeHelper;
import tools.vitruv.dsls.reactions.util.ReactionsLanguageUtil;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ReactionsLanguageValidator extends AbstractReactionsLanguageValidator {
  @Inject
  private ReactionsImportScopeHelper reactionsImportScopeHelper;

  @Check
  public void checkReactionsFile(final ReactionsFile reactionsFile) {
    final HashMap<String, ReactionsSegment> alreadyCheckedSegments = new HashMap<String, ReactionsSegment>();
    EList<ReactionsSegment> _reactionsSegments = reactionsFile.getReactionsSegments();
    for (final ReactionsSegment reactionsSegment : _reactionsSegments) {
      {
        final String reactionsSegmentName = ReactionsLanguageUtil.getFormattedName(reactionsSegment);
        ReactionsSegment _putIfAbsent = alreadyCheckedSegments.putIfAbsent(reactionsSegmentName, reactionsSegment);
        boolean _tripleNotEquals = (_putIfAbsent != null);
        if (_tripleNotEquals) {
          final String errorMessage = ("Duplicate reactions segment name: " + reactionsSegmentName);
          this.error(errorMessage, reactionsSegment, TopLevelElementsPackage.Literals.REACTIONS_SEGMENT__NAME);
          final ReactionsSegment duplicateNameSegment = alreadyCheckedSegments.get(reactionsSegmentName);
          this.error(errorMessage, duplicateNameSegment, TopLevelElementsPackage.Literals.REACTIONS_SEGMENT__NAME);
        }
      }
    }
  }

  @Check
  public void checkReactionsSegment(final ReactionsSegment reactionsSegment) {
    final String segmentName = reactionsSegment.getName();
    final String segmentFormattedName = ReactionsLanguageUtil.getFormattedName(reactionsSegment);
    boolean _startsWith = segmentName.startsWith("_");
    if (_startsWith) {
      this.error("Reactions segment names must not start with an underscore.", 
        TopLevelElementsPackage.Literals.REACTIONS_SEGMENT__NAME);
    }
    boolean _isLowerCase = Character.isLowerCase(segmentName.charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Reactions segment names should start lower case.", 
        TopLevelElementsPackage.Literals.REACTIONS_SEGMENT__NAME);
    }
    final Resource resource = reactionsSegment.eResource();
    final Iterable<IEObjectDescription> visibleReactionsSegmentDescs = this.reactionsImportScopeHelper.getVisibleReactionsSegmentDescriptions(reactionsSegment);
    final Function1<IEObjectDescription, Boolean> _function = (IEObjectDescription it) -> {
      return Boolean.valueOf(ReactionsLanguageUtil.getFormattedReactionsSegmentName(it.getName().toString()).equals(segmentFormattedName));
    };
    final IEObjectDescription duplicateNameSegmentDesc = IterableExtensions.<IEObjectDescription>findFirst(visibleReactionsSegmentDescs, _function);
    if ((duplicateNameSegmentDesc != null)) {
      final URI pathToOtherSegment = duplicateNameSegmentDesc.getEObjectURI().trimFragment().deresolve(resource.getURI());
      this.warning(
        ((("Duplicate reactions segment name \'" + segmentFormattedName) + "\': Already defined in ") + pathToOtherSegment), reactionsSegment, 
        TopLevelElementsPackage.Literals.REACTIONS_SEGMENT__NAME);
    }
    this.checkNoDifferentMetamodelPairImports(reactionsSegment);
    this.checkNoDuplicateImports(reactionsSegment);
    this.checkNoCyclicImports(reactionsSegment);
    this.checkNoDuplicateIncludedReactions(reactionsSegment);
    this.checkNoIncludedRoutinesNameClashes(reactionsSegment);
    this.checkNoIncludedRoutinesFacadesNameClashes(reactionsSegment);
    this.checkNoDuplicateReactionNames(reactionsSegment);
    this.checkNoDuplicateReactionNamesInIncludedReactions(reactionsSegment);
    this.checkNoDuplicateRoutineNames(reactionsSegment);
  }

  private void checkNoDifferentMetamodelPairImports(final ReactionsSegment reactionsSegment) {
    final String metamodelPairName = ReactionsLanguageUtil.getFormattedMetamodelPair(reactionsSegment);
    final Function1<ReactionsImport, Boolean> _function = (ReactionsImport it) -> {
      boolean _isRoutinesOnly = it.isRoutinesOnly();
      return Boolean.valueOf((_isRoutinesOnly == false));
    };
    Iterable<ReactionsImport> _filter = IterableExtensions.<ReactionsImport>filter(reactionsSegment.getReactionsImports(), _function);
    for (final ReactionsImport reactionsImport : _filter) {
      {
        final ReactionsSegment importedSegment = reactionsImport.getImportedReactionsSegment();
        final String importedMetamodelPairName = ReactionsLanguageUtil.getFormattedMetamodelPair(importedSegment);
        boolean _equals = metamodelPairName.equals(importedMetamodelPairName);
        boolean _not = (!_equals);
        if (_not) {
          final String errorMessage = ("Cannot import reactions segment using a different metamodel pair: " + importedMetamodelPairName);
          this.error(errorMessage, reactionsImport, 
            TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
        }
      }
    }
  }

  private void checkNoDuplicateImports(final ReactionsSegment reactionsSegment) {
    final HashMap<String, ReactionsImport> alreadyCheckedImports = new HashMap<String, ReactionsImport>();
    EList<ReactionsImport> _reactionsImports = reactionsSegment.getReactionsImports();
    for (final ReactionsImport reactionsImport : _reactionsImports) {
      {
        final ReactionsSegment importedSegment = reactionsImport.getImportedReactionsSegment();
        final String importedSegmentFormattedName = ReactionsLanguageUtil.getFormattedName(importedSegment);
        final ReactionsImport duplicateImport = alreadyCheckedImports.putIfAbsent(importedSegmentFormattedName, reactionsImport);
        if ((duplicateImport != null)) {
          final String errorMessage = ("Duplicate reactions import: " + importedSegmentFormattedName);
          this.error(errorMessage, reactionsImport, 
            TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
          this.error(errorMessage, duplicateImport, 
            TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
        }
      }
    }
  }

  private void checkNoCyclicImports(final ReactionsSegment reactionsSegment) {
    final String segmentFormattedName = ReactionsLanguageUtil.getFormattedName(reactionsSegment);
    EList<ReactionsImport> _reactionsImports = reactionsSegment.getReactionsImports();
    for (final ReactionsImport reactionsImport : _reactionsImports) {
      {
        final ReactionsSegment importedSegment = reactionsImport.getImportedReactionsSegment();
        final Collection<ReactionsSegment> importImportedSegments = ReactionsImportsHelper.getRoutinesImportHierarchy(importedSegment).values();
        final Function1<ReactionsSegment, Boolean> _function = (ReactionsSegment it) -> {
          return Boolean.valueOf(ReactionsLanguageUtil.getFormattedName(it).equals(segmentFormattedName));
        };
        ReactionsSegment _findFirst = IterableExtensions.<ReactionsSegment>findFirst(importImportedSegments, _function);
        boolean _tripleNotEquals = (_findFirst != null);
        if (_tripleNotEquals) {
          final String errorMessage = ("Cyclic reactions import! Cannot transitively import self: " + segmentFormattedName);
          this.error(errorMessage, reactionsImport, 
            TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
        }
      }
    }
  }

  private void checkNoDuplicateIncludedReactions(final ReactionsSegment reactionsSegment) {
    final HashMap<String, ReactionsImport> alreadyCheckedIncludedReactions = new HashMap<String, ReactionsImport>();
    final Function1<ReactionsImport, Boolean> _function = (ReactionsImport it) -> {
      boolean _isRoutinesOnly = it.isRoutinesOnly();
      return Boolean.valueOf((!_isRoutinesOnly));
    };
    Iterable<ReactionsImport> _filter = IterableExtensions.<ReactionsImport>filter(reactionsSegment.getReactionsImports(), _function);
    for (final ReactionsImport reactionsImport : _filter) {
      {
        final ReactionsSegment importedSegment = reactionsImport.getImportedReactionsSegment();
        final Collection<ReactionsSegment> importIncludedReactionsSegments = ReactionsImportsHelper.getReactionsImportHierarchy(importedSegment).values();
        for (final ReactionsSegment includedReactionsSegment : importIncludedReactionsSegments) {
          {
            final String includedReactionsSegmentFormattedName = ReactionsLanguageUtil.getFormattedName(includedReactionsSegment);
            final ReactionsImport duplicateReactionsImport = alreadyCheckedIncludedReactions.putIfAbsent(includedReactionsSegmentFormattedName, reactionsImport);
            if ((duplicateReactionsImport != null)) {
              final String errorMessage = (("Cannot (possibly transitively) import reactions of the same reactions segment (\'" + includedReactionsSegmentFormattedName) + 
                "\') more than once. Consider importing only the routines for one of them.");
              this.error(errorMessage, reactionsImport, 
                TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
              this.error(errorMessage, duplicateReactionsImport, 
                TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
            }
          }
        }
      }
    }
  }

  private void checkNoDuplicateReactionNamesInIncludedReactions(final ReactionsSegment reactionsSegment) {
    final Function1<Reaction, String> _function = (Reaction it) -> {
      return ReactionsLanguageUtil.getFormattedName(it);
    };
    final Map<String, Reaction> localReactions = IterableExtensions.<String, Reaction>toMap(ReactionsLanguageUtil.getRegularReactions(reactionsSegment), _function);
    final Function2<ReactionsImportPath, ReactionsSegment, Boolean> _function_1 = (ReactionsImportPath importPath, ReactionsSegment segment) -> {
      int _length = importPath.getLength();
      return Boolean.valueOf((_length > 1));
    };
    final Function1<ReactionsSegment, Iterable<Reaction>> _function_2 = (ReactionsSegment it) -> {
      return ReactionsLanguageUtil.getRegularReactions(it);
    };
    final Iterable<Reaction> importedReactions = Iterables.<Reaction>concat(IterableExtensions.<ReactionsSegment, Iterable<Reaction>>map(MapExtensions.<ReactionsImportPath, ReactionsSegment>filter(ReactionsImportsHelper.getReactionsImportHierarchy(reactionsSegment), _function_1).values(), _function_2));
    for (final Reaction importedReaction : importedReactions) {
      {
        final String importedReactionName = ReactionsLanguageUtil.getFormattedName(importedReaction);
        final Reaction duplicateReaction = localReactions.get(importedReactionName);
        if ((duplicateReaction != null)) {
          String _formattedName = ReactionsLanguageUtil.getFormattedName(importedReaction.getReactionsSegment());
          String _plus = ((("A reaction with this name (\'" + importedReactionName) + 
            "\') already exists in segment \'") + _formattedName);
          final String errorMessage = (_plus + 
            "\'. Consider using a different name.");
          this.warning(errorMessage, duplicateReaction, TopLevelElementsPackage.Literals.REACTION__NAME);
        }
      }
    }
  }

  private void checkNoIncludedRoutinesNameClashes(final ReactionsSegment reactionsSegment) {
    final Function1<Routine, String> _function = (Routine it) -> {
      return ReactionsLanguageUtil.getFormattedName(it);
    };
    final Map<String, Routine> localRoutines = IterableExtensions.<String, Routine>toMap(ReactionsLanguageUtil.getRegularRoutines(reactionsSegment), _function);
    final HashMap<String, ReactionsImport> alreadyCheckedIncludedRoutines = new HashMap<String, ReactionsImport>();
    final Function1<ReactionsImport, Boolean> _function_1 = (ReactionsImport it) -> {
      boolean _isUseQualifiedNames = it.isUseQualifiedNames();
      return Boolean.valueOf((!_isUseQualifiedNames));
    };
    Iterable<ReactionsImport> _filter = IterableExtensions.<ReactionsImport>filter(reactionsSegment.getReactionsImports(), _function_1);
    for (final ReactionsImport reactionsImport : _filter) {
      {
        final ReactionsSegment importedSegment = reactionsImport.getImportedReactionsSegment();
        final Set<Routine> importIncludedRoutines = ReactionsImportsHelper.getIncludedRoutines(importedSegment, true, false).keySet();
        for (final Routine includedRoutine : importIncludedRoutines) {
          {
            final String includedRoutineName = ReactionsLanguageUtil.getFormattedName(includedRoutine);
            final Routine duplicateRoutine = localRoutines.get(includedRoutineName);
            if ((duplicateRoutine != null)) {
              final String errorMessage = (("Name-clash between imported and local routine (\'" + includedRoutineName) + 
                "\'). Consider importing using qualified names.");
              this.error(errorMessage, reactionsImport, 
                TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
              this.error(errorMessage, duplicateRoutine, TopLevelElementsPackage.Literals.ROUTINE__NAME);
            }
            final ReactionsImport duplicateReactionsImport = alreadyCheckedIncludedRoutines.putIfAbsent(includedRoutineName, reactionsImport);
            if ((duplicateReactionsImport != null)) {
              final String errorMessage_1 = (("Name-clash between imported routines (\'" + includedRoutineName) + 
                "\'). Consider importing one of them using qualified names.");
              this.error(errorMessage_1, reactionsImport, 
                TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
              this.error(errorMessage_1, duplicateReactionsImport, 
                TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
            }
          }
        }
      }
    }
  }

  private void checkNoIncludedRoutinesFacadesNameClashes(final ReactionsSegment reactionsSegment) {
    final HashMap<String, ReactionsImport> alreadyCheckedIncludedRoutinesFacades = new HashMap<String, ReactionsImport>();
    EList<ReactionsImport> _reactionsImports = reactionsSegment.getReactionsImports();
    for (final ReactionsImport reactionsImport : _reactionsImports) {
      {
        final ReactionsSegment importedSegment = reactionsImport.getImportedReactionsSegment();
        boolean _isUseQualifiedNames = reactionsImport.isUseQualifiedNames();
        if (_isUseQualifiedNames) {
          final String includedRoutinesFacadeName = ReactionsLanguageUtil.getFormattedName(importedSegment);
          final ReactionsImport duplicateReactionsImport = alreadyCheckedIncludedRoutinesFacades.putIfAbsent(includedRoutinesFacadeName, reactionsImport);
          if ((duplicateReactionsImport != null)) {
            this.errorIncludedRoutinesFacadesNameClash(reactionsImport, duplicateReactionsImport, includedRoutinesFacadeName);
          }
        } else {
          final Set<ReactionsSegment> importIncludedRoutinesFacadeSegments = ReactionsImportsHelper.getIncludedRoutinesFacades(importedSegment).keySet();
          for (final ReactionsSegment includedRoutinesFacadeSegment : importIncludedRoutinesFacadeSegments) {
            {
              final String includedRoutinesFacadeName_1 = ReactionsLanguageUtil.getFormattedName(includedRoutinesFacadeSegment);
              final ReactionsImport duplicateReactionsImport_1 = alreadyCheckedIncludedRoutinesFacades.putIfAbsent(includedRoutinesFacadeName_1, reactionsImport);
              if ((duplicateReactionsImport_1 != null)) {
                this.errorIncludedRoutinesFacadesNameClash(reactionsImport, duplicateReactionsImport_1, includedRoutinesFacadeName_1);
              }
            }
          }
        }
      }
    }
  }

  private void errorIncludedRoutinesFacadesNameClash(final ReactionsImport checkedImport, final ReactionsImport conflictingImport, final String conflictingSegmentName) {
    final String errorMessage = (("Name-clash between routines imported (possibly transitively) with qualified names (\'" + conflictingSegmentName) + "\'). Consider importing one of them without qualified names.");
    this.error(errorMessage, checkedImport, 
      TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
    this.error(errorMessage, conflictingImport, 
      TopLevelElementsPackage.Literals.REACTIONS_IMPORT__IMPORTED_REACTIONS_SEGMENT);
  }

  private void checkNoDuplicateReactionNames(final ReactionsSegment reactionsSegment) {
    final HashMap<String, Reaction> alreadyCheckedReactions = new HashMap<String, Reaction>();
    EList<Reaction> _reactions = reactionsSegment.getReactions();
    for (final Reaction reaction : _reactions) {
      {
        final String reactionName = ReactionsLanguageUtil.getDisplayName(reaction);
        Reaction _putIfAbsent = alreadyCheckedReactions.putIfAbsent(reactionName, reaction);
        boolean _tripleNotEquals = (_putIfAbsent != null);
        if (_tripleNotEquals) {
          final String errorMessage = ("Duplicate reaction name: " + reactionName);
          this.error(errorMessage, reaction, TopLevelElementsPackage.Literals.REACTION__NAME);
          this.error(errorMessage, 
            alreadyCheckedReactions.get(reactionName), 
            TopLevelElementsPackage.Literals.REACTION__NAME);
        }
      }
    }
  }

  private void checkNoDuplicateRoutineNames(final ReactionsSegment reactionsSegment) {
    final HashMap<String, Routine> alreadyCheckedRoutines = new HashMap<String, Routine>();
    EList<Routine> _routines = reactionsSegment.getRoutines();
    for (final Routine routine : _routines) {
      {
        final String routineName = ReactionsLanguageUtil.getDisplayName(routine);
        Routine _putIfAbsent = alreadyCheckedRoutines.putIfAbsent(routineName, routine);
        boolean _tripleNotEquals = (_putIfAbsent != null);
        if (_tripleNotEquals) {
          final String errorMessage = ("Duplicate routine name: " + routineName);
          this.error(errorMessage, routine, TopLevelElementsPackage.Literals.ROUTINE__NAME);
          final Routine duplicateNameRoutine = alreadyCheckedRoutines.get(routineName);
          this.error(errorMessage, duplicateNameRoutine, TopLevelElementsPackage.Literals.ROUTINE__NAME);
        }
      }
    }
  }

  @Check
  public void checkRetrieveElementName(final RetrieveModelElement element) {
    if (((!StringExtensions.isNullOrEmpty(element.getName())) && element.getName().startsWith("_"))) {
      this.error("Element names must not start with an underscore.", 
        LanguagePackage.Literals.RETRIEVE_MODEL_ELEMENT__NAME);
    }
  }

  @Check
  public void checkCreateElementName(final CreateBlock createBlock) {
    EList<NamedMetaclassReference> _createStatements = createBlock.getCreateStatements();
    for (final NamedMetaclassReference element : _createStatements) {
      if (((!StringExtensions.isNullOrEmpty(element.getName())) && element.getName().startsWith("_"))) {
        this.error("Element names must not start with an underscore.", 
          ElementsPackage.Literals.NAMED_METACLASS_REFERENCE__NAME);
      }
    }
  }

  @Check
  public void checkRoutine(final Routine routine) {
    boolean _startsWith = routine.getName().startsWith("_");
    if (_startsWith) {
      this.error("Routine names must not start with an underscore.", TopLevelElementsPackage.Literals.ROUTINE__NAME);
    }
    boolean _isLowerCase = Character.isLowerCase(routine.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Routine names should start lower case", TopLevelElementsPackage.Literals.ROUTINE__NAME);
    }
    boolean _isOverride = ReactionsLanguageUtil.isOverride(routine);
    if (_isOverride) {
      final ReactionsImportPath overrideImportPath = ReactionsLanguageUtil.toReactionsImportPath(routine.getOverrideImportPath());
      boolean _isComplete = ReactionsElementsCompletionChecker.isComplete(routine.getOverrideImportPath());
      boolean _not_1 = (!_isComplete);
      if (_not_1) {
        String _pathString = overrideImportPath.getPathString();
        final String errorMessage = ("Incomplete override import path: " + _pathString);
        this.error(errorMessage, routine, TopLevelElementsPackage.Literals.ROUTINE__OVERRIDE_IMPORT_PATH);
      } else {
        final ReactionsSegment overriddenReactionsSegment = ReactionsImportsHelper.getReactionsSegment(routine.getReactionsSegment(), overrideImportPath);
        if ((overriddenReactionsSegment == null)) {
          String _pathString_1 = overrideImportPath.getPathString();
          final String errorMessage_1 = ("Can not find overridden reactions segment for this import path: " + _pathString_1);
          this.error(errorMessage_1, routine, TopLevelElementsPackage.Literals.ROUTINE__OVERRIDE_IMPORT_PATH);
        } else {
          final String routineName = ReactionsLanguageUtil.getFormattedName(routine);
          final Function1<Routine, Boolean> _function = (Routine it) -> {
            return Boolean.valueOf(ReactionsLanguageUtil.getFormattedName(it).equals(routineName));
          };
          final Routine overriddenRoutine = IterableExtensions.<Routine>findFirst(ReactionsLanguageUtil.getRegularRoutines(overriddenReactionsSegment), _function);
          if ((overriddenRoutine == null)) {
            final String errorMessage_2 = ("Routine name does not match any routine in the overridden reactions segment: " + routineName);
            this.error(errorMessage_2, routine, TopLevelElementsPackage.Literals.ROUTINE__NAME);
          } else {
            final String inputSignature = this.getInputSignature(routine);
            final String overriddenInputSignature = this.getInputSignature(overriddenRoutine);
            boolean _equals = inputSignature.equals(overriddenInputSignature);
            boolean _not_2 = (!_equals);
            if (_not_2) {
              final String errorMessage_3 = ("Input parameters need to match those of the overridden routine: " + overriddenInputSignature);
              this.error(errorMessage_3, routine, TopLevelElementsPackage.Literals.ROUTINE__INPUT);
            }
          }
        }
      }
    }
  }

  private String getInputSignature(final Routine routine) {
    final StringBuilder signature = new StringBuilder();
    signature.append("(");
    EList<NamedMetaclassReference> _modelInputElements = routine.getInput().getModelInputElements();
    for (final NamedMetaclassReference modelInputElement : _modelInputElements) {
      signature.append(ReactionsLanguageHelper.getJavaClassName(modelInputElement.getMetaclass()));
    }
    EList<NamedJavaElementReference> _javaInputElements = routine.getInput().getJavaInputElements();
    for (final NamedJavaElementReference javaInputElement : _javaInputElements) {
      signature.append(javaInputElement.getType().getIdentifier());
    }
    signature.append(")");
    return signature.toString();
  }

  @Check
  public void checkReaction(final Reaction reaction) {
    boolean _isUpperCase = Character.isUpperCase(reaction.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Reaction names should start upper case", TopLevelElementsPackage.Literals.REACTION__NAME);
    }
    boolean _isOverride = ReactionsLanguageUtil.isOverride(reaction);
    if (_isOverride) {
      final String reactionName = ReactionsLanguageUtil.getFormattedName(reaction);
      final Function1<Reaction, Boolean> _function = (Reaction it) -> {
        return Boolean.valueOf(ReactionsLanguageUtil.getFormattedName(it).equals(reactionName));
      };
      final Reaction overriddenReaction = IterableExtensions.<Reaction>findFirst(ReactionsLanguageUtil.getRegularReactions(reaction.getOverriddenReactionsSegment()), _function);
      if ((overriddenReaction == null)) {
        final String errorMessage = ("Reaction name does not match any reaction in the overridden reactions segment: " + reactionName);
        this.error(errorMessage, reaction, TopLevelElementsPackage.Literals.REACTION__NAME);
      }
    }
  }

  @Check
  public void checkMetaclassFeature(final ModelElementChange elementChange) {
    MetaclassReference _elementType = null;
    if (elementChange!=null) {
      _elementType=elementChange.getElementType();
    }
    EClassifier _metaclass = null;
    if (_elementType!=null) {
      _metaclass=_elementType.getMetaclass();
    }
    final EClass elementType = ((EClass) _metaclass);
    ElementChangeType _changeType = null;
    if (elementChange!=null) {
      _changeType=elementChange.getChangeType();
    }
    final ElementChangeType elementChangeType = _changeType;
    ElementChangeType atomicChangeType = null;
    if ((elementChangeType instanceof ElementReferenceChangeType)) {
      atomicChangeType = elementChangeType;
    }
    if ((atomicChangeType instanceof ElementReferenceChangeType)) {
      MetaclassEReferenceReference _feature = ((ElementReferenceChangeType)atomicChangeType).getFeature();
      EReference _feature_1 = null;
      if (_feature!=null) {
        _feature_1=_feature.getFeature();
      }
      EClassifier _eType = null;
      if (_feature_1!=null) {
        _eType=_feature_1.getEType();
      }
      final EClass featureType = ((EClass) _eType);
      if (((elementType != null) && (featureType != null))) {
        if ((((!elementType.equals(featureType)) && (!elementType.getEAllSuperTypes().contains(featureType))) && 
          (!featureType.getEAllSuperTypes().contains(elementType)))) {
          this.error(
            "Element of specified type cannot be contained in the specified features", elementChange, 
            LanguagePackage.Literals.MODEL_ELEMENT_CHANGE__ELEMENT_TYPE);
        }
      }
    }
    if ((atomicChangeType instanceof ElementReferenceChangeType)) {
      MetaclassEReferenceReference _feature_2 = ((ElementReferenceChangeType)atomicChangeType).getFeature();
      EReference _feature_3 = null;
      if (_feature_2!=null) {
        _feature_3=_feature_2.getFeature();
      }
      final EReference featureVal = _feature_3;
      if ((featureVal instanceof ETypedElement)) {
        boolean _isMany = featureVal.isMany();
        boolean _not = (!_isMany);
        if (_not) {
          if ((elementChangeType instanceof ElementInsertionInListChangeType)) {
            this.error(
              "Element cannot be inserted into single valued reference", elementChange, 
              LanguagePackage.Literals.MODEL_ELEMENT_CHANGE__CHANGE_TYPE);
          } else {
            if ((elementChangeType instanceof ElementRemovalFromListChangeType)) {
              this.error(
                "Element cannot be removed from single valued reference", elementChange, 
                LanguagePackage.Literals.MODEL_ELEMENT_CHANGE__CHANGE_TYPE);
            }
          }
        }
      }
    }
  }
}
