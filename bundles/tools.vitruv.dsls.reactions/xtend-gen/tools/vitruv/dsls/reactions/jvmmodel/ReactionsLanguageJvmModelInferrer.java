/**
 * generated by Xtext 2.9.0
 */
package tools.vitruv.dsls.reactions.jvmmodel;

import com.google.inject.Inject;
import java.util.Arrays;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import tools.vitruv.dsls.reactions.codegen.classgenerators.ChangePropagationSpecificationClassGenerator;
import tools.vitruv.dsls.reactions.codegen.classgenerators.ClassGenerator;
import tools.vitruv.dsls.reactions.codegen.classgenerators.OverriddenRoutinesFacadeClassGenerator;
import tools.vitruv.dsls.reactions.codegen.classgenerators.ReactionClassGenerator;
import tools.vitruv.dsls.reactions.codegen.classgenerators.RoutineClassGenerator;
import tools.vitruv.dsls.reactions.codegen.classgenerators.RoutineFacadeClassGenerator;
import tools.vitruv.dsls.reactions.codegen.classgenerators.RoutinesFacadesProviderClassGenerator;
import tools.vitruv.dsls.reactions.codegen.helper.ReactionsElementsCompletionChecker;
import tools.vitruv.dsls.reactions.codegen.helper.ReactionsImportsHelper;
import tools.vitruv.dsls.reactions.codegen.typesbuilder.JvmTypesBuilderWithoutAssociations;
import tools.vitruv.dsls.reactions.codegen.typesbuilder.TypesBuilderExtensionProvider;
import tools.vitruv.dsls.reactions.language.toplevelelements.Reaction;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsFile;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsSegment;
import tools.vitruv.dsls.reactions.language.toplevelelements.Routine;
import tools.vitruv.dsls.reactions.runtime.structure.ReactionsImportPath;

/**
 * <p>Infers a JVM model for the Xtend code blocks of the reaction file model.</p>
 * 
 * <p>The resulting classes are not to be persisted but only to be used for content assist purposes.</p>
 * 
 * @author Heiko Klare
 */
@SuppressWarnings("all")
public class ReactionsLanguageJvmModelInferrer extends AbstractModelInferrer {
  @Inject
  @Extension
  private JvmTypesBuilderWithoutAssociations _typesBuilder;

  @Inject
  private TypesBuilderExtensionProvider typesBuilderExtensionProvider;

  private void updateBuilders() {
    this.typesBuilderExtensionProvider.setBuilders(this._typesBuilder, this._typeReferenceBuilder, this._annotationTypesBuilder);
  }

  protected void _generate(final Reaction reaction, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    ReactionClassGenerator _reactionClassGenerator = new ReactionClassGenerator(reaction, this.typesBuilderExtensionProvider);
    ReactionsLanguageJvmModelInferrer.accept(acceptor, _reactionClassGenerator, reaction.getReactionsSegment());
  }

  protected void _generate(final Routine routine, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    RoutineClassGenerator _routineClassGenerator = new RoutineClassGenerator(routine, this.typesBuilderExtensionProvider);
    ReactionsLanguageJvmModelInferrer.accept(acceptor, _routineClassGenerator, routine.getReactionsSegment());
  }

  protected void _infer(final ReactionsFile file, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    this.updateBuilders();
    final Function1<ReactionsSegment, Boolean> _function = (ReactionsSegment it) -> {
      return Boolean.valueOf(ReactionsElementsCompletionChecker.isReferenceable(it));
    };
    Iterable<ReactionsSegment> _filter = IterableExtensions.<ReactionsSegment>filter(file.getReactionsSegments(), _function);
    for (final ReactionsSegment reactionsSegment : _filter) {
      {
        RoutineFacadeClassGenerator _routineFacadeClassGenerator = new RoutineFacadeClassGenerator(reactionsSegment, this.typesBuilderExtensionProvider);
        ReactionsLanguageJvmModelInferrer.accept(acceptor, _routineFacadeClassGenerator, reactionsSegment);
        Set<ReactionsImportPath> _parsedOverriddenRoutinesImportPaths = ReactionsImportsHelper.getParsedOverriddenRoutinesImportPaths(reactionsSegment);
        for (final ReactionsImportPath overriddenRoutinesImportPath : _parsedOverriddenRoutinesImportPaths) {
          OverriddenRoutinesFacadeClassGenerator _overriddenRoutinesFacadeClassGenerator = new OverriddenRoutinesFacadeClassGenerator(reactionsSegment, overriddenRoutinesImportPath, this.typesBuilderExtensionProvider);
          ReactionsLanguageJvmModelInferrer.accept(acceptor, _overriddenRoutinesFacadeClassGenerator, reactionsSegment);
        }
        RoutinesFacadesProviderClassGenerator _routinesFacadesProviderClassGenerator = new RoutinesFacadesProviderClassGenerator(reactionsSegment, this.typesBuilderExtensionProvider);
        ReactionsLanguageJvmModelInferrer.accept(acceptor, _routinesFacadesProviderClassGenerator, reactionsSegment);
        final Function1<Routine, Boolean> _function_1 = (Routine it) -> {
          return Boolean.valueOf(ReactionsElementsCompletionChecker.isReferenceable(it));
        };
        Iterable<Routine> _filter_1 = IterableExtensions.<Routine>filter(reactionsSegment.getRoutines(), _function_1);
        for (final Routine effect : _filter_1) {
          this.generate(effect, acceptor, isPreIndexingPhase);
        }
        final Function1<Reaction, Boolean> _function_2 = (Reaction it) -> {
          return Boolean.valueOf(ReactionsElementsCompletionChecker.isReferenceable(it));
        };
        Iterable<Reaction> _filter_2 = IterableExtensions.<Reaction>filter(reactionsSegment.getReactions(), _function_2);
        for (final Reaction reaction : _filter_2) {
          this.generate(reaction, acceptor, isPreIndexingPhase);
        }
        ChangePropagationSpecificationClassGenerator _changePropagationSpecificationClassGenerator = new ChangePropagationSpecificationClassGenerator(reactionsSegment, this.typesBuilderExtensionProvider);
        ReactionsLanguageJvmModelInferrer.accept(acceptor, _changePropagationSpecificationClassGenerator, reactionsSegment);
      }
    }
  }

  private static void accept(final IJvmDeclaredTypeAcceptor acceptor, @Extension final ClassGenerator generator, final ReactionsSegment reactionsSegment) {
    final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
      boolean _isAllImportsResolvable = ReactionsImportsHelper.isAllImportsResolvable(reactionsSegment);
      if (_isAllImportsResolvable) {
        generator.generateBody();
      }
    };
    acceptor.<JvmGenericType>accept(generator.generateEmptyClass(), _function);
  }

  public void generate(final EObject reaction, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (reaction instanceof Reaction) {
      _generate((Reaction)reaction, acceptor, isPreIndexingPhase);
      return;
    } else if (reaction instanceof Routine) {
      _generate((Routine)reaction, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(reaction, acceptor, isPreIndexingPhase).toString());
    }
  }

  public void infer(final EObject file, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (file instanceof ReactionsFile) {
      _infer((ReactionsFile)file, acceptor, isPreIndexingPhase);
      return;
    } else if (file != null) {
      _infer(file, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(file, acceptor, isPreIndexingPhase).toString());
    }
  }
}
