package tools.vitruv.dsls.reactions.builder;

import com.google.common.io.CharStreams;
import com.google.inject.Inject;
import com.google.inject.Provider;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.URI;
import org.eclipse.xtext.generator.InMemoryFileSystemAccess;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import tools.vitruv.dsls.reactions.api.generator.IReactionsGenerator;
import tools.vitruv.dsls.reactions.language.toplevelelements.ReactionsFile;

/**
 * A matcher checking reactions generated by a
 * {@link FluentReactionsFileBuilder}. See {@link #builds} for details.
 */
@SuppressWarnings("all")
public class GeneratedReactionsMatcherBuilder {
  public static class GeneratedReactionsMatcher extends TypeSafeMatcher<FluentReactionsFileBuilder> {
    @Extension
    private final GeneratedReactionsMatcherBuilder generatedReactions;

    private final String expectedReaction;

    private Consumer<Description> mismatch;

    public GeneratedReactionsMatcher(final GeneratedReactionsMatcherBuilder generatedReactions, final String expectedReaction) {
      this.generatedReactions = generatedReactions;
      this.expectedReaction = expectedReaction;
    }

    @Override
    protected boolean matchesSafely(final FluentReactionsFileBuilder item) {
      try {
        final IReactionsGenerator generator = this.generatedReactions.generatorProvider.get();
        final InMemoryFileSystemAccess fsa = this.generatedReactions.inMemoryFileSystemAccessProvider.get();
        generator.useResourceSet(this.generatedReactions.resourceSetProvider.get());
        generator.addReactionsFile(item);
        generator.writeReactions(fsa);
        boolean _hasSingleGeneratedFile = this.hasSingleGeneratedFile(fsa);
        boolean _not = (!_hasSingleGeneratedFile);
        if (_not) {
          return false;
        }
        final String serializationResult = this.getSingleGeneratedFileContent(fsa);
        boolean _isEqual = this.isEqual(this.expectedReaction, serializationResult);
        boolean _not_1 = (!_isEqual);
        if (_not_1) {
          return false;
        }
        final Map<String, CharSequence> expectedGeneratedCodeFileNamesToContents = this.generateCodeFiles(this.expectedReaction);
        final Map<String, CharSequence> actualGeneratedCodeFileNamesToContents = this.generateCodeFiles(serializationResult);
        return this.areEqual(expectedGeneratedCodeFileNamesToContents, actualGeneratedCodeFileNamesToContents);
      } catch (Throwable _e) {
        throw Exceptions.sneakyThrow(_e);
      }
    }

    private boolean hasSingleGeneratedFile(final InMemoryFileSystemAccess fsa) {
      int _size = fsa.getAllFiles().size();
      boolean _tripleNotEquals = (_size != 1);
      if (_tripleNotEquals) {
        int _size_1 = fsa.getAllFiles().size();
        boolean _tripleEquals = (_size_1 == 0);
        if (_tripleEquals) {
          final Consumer<Description> _function = (Description it) -> {
            it.appendText("serializing the builder had no results");
          };
          this.mismatch = _function;
        } else {
          final Consumer<Description> _function_1 = (Description it) -> {
            it.appendText("serializing the builder had more than one result: ").<String>appendValueList("[", ", ", "]", 
              fsa.getAllFiles().keySet());
          };
          this.mismatch = _function_1;
        }
        return false;
      }
      return true;
    }

    private String getSingleGeneratedFileContent(final InMemoryFileSystemAccess fsa) {
      return this.generatedReactions.read(fsa, IterableExtensions.<String>head(fsa.getAllFiles().keySet()));
    }

    private boolean isEqual(final String expectedReactionsCode, final String generatedReactionsCode) {
      boolean _equalsIgnoringWhitespace = GeneratedReactionsMatcherBuilder.equalsIgnoringWhitespace(expectedReactionsCode, generatedReactionsCode);
      boolean _not = (!_equalsIgnoringWhitespace);
      if (_not) {
        final Consumer<Description> _function = (Description it) -> {
          it.appendText("serializing the builder resulted in a different reactions file:\n\n").appendText(generatedReactionsCode).appendText("\n\nFirst mismatching line:\n\n").appendValue(
            GeneratedReactionsMatcherBuilder.firstMismatchLineIgnoringWhitespace(generatedReactionsCode, expectedReactionsCode));
        };
        this.mismatch = _function;
        return false;
      }
      return true;
    }

    private Map<String, CharSequence> generateCodeFiles(final String reactionsCode) {
      try {
        final XtextResourceSet resourceSet = this.generatedReactions.resourceSetProvider.get();
        this.generatedReactions.parseHelper.parse(reactionsCode, GeneratedReactionsMatcherBuilder.SYNTHETIC.appendSegment("reaction").appendFileExtension("reactions"), resourceSet);
        final InMemoryFileSystemAccess fsa = this.generatedReactions.inMemoryFileSystemAccessProvider.get();
        final IReactionsGenerator generator = this.generatedReactions.generatorProvider.get();
        generator.addReactionsFiles(resourceSet);
        generator.generate(fsa);
        return fsa.getTextFiles();
      } catch (Throwable _e) {
        throw Exceptions.sneakyThrow(_e);
      }
    }

    private boolean areEqual(final Map<String, CharSequence> expectedGeneratedCodeFileNamesToContents, final Map<String, CharSequence> actualGeneratedCodeFileNamesToContents) {
      final Function1<String, Boolean> _function = (String it) -> {
        boolean _containsKey = expectedGeneratedCodeFileNamesToContents.containsKey(it);
        return Boolean.valueOf((!_containsKey));
      };
      final String unexpectedItemFile = IterableExtensions.<String>findFirst(actualGeneratedCodeFileNamesToContents.keySet(), _function);
      if ((unexpectedItemFile != null)) {
        final Consumer<Description> _function_1 = (Description it) -> {
          it.appendText("generating from the builder produced the unexpected file ").appendValue(unexpectedItemFile);
        };
        this.mismatch = _function_1;
        return false;
      }
      final Function1<String, Boolean> _function_2 = (String it) -> {
        boolean _containsKey = actualGeneratedCodeFileNamesToContents.containsKey(it);
        return Boolean.valueOf((!_containsKey));
      };
      final String missingItemFile = IterableExtensions.<String>findFirst(expectedGeneratedCodeFileNamesToContents.keySet(), _function_2);
      if ((missingItemFile != null)) {
        final Consumer<Description> _function_3 = (Description it) -> {
          it.appendText("generating from the builder did not produce the expected file ").appendValue(missingItemFile);
        };
        this.mismatch = _function_3;
      }
      Set<String> _keySet = expectedGeneratedCodeFileNamesToContents.keySet();
      for (final String filePath : _keySet) {
        {
          final String expectedContent = expectedGeneratedCodeFileNamesToContents.get(filePath).toString();
          final String itemContent = actualGeneratedCodeFileNamesToContents.get(filePath).toString();
          boolean _equalsIgnoringWhitespace = GeneratedReactionsMatcherBuilder.equalsIgnoringWhitespace(expectedContent, itemContent);
          boolean _not = (!_equalsIgnoringWhitespace);
          if (_not) {
            final Consumer<Description> _function_4 = (Description it) -> {
              it.appendText("generating from the builder produced wrong content for ").appendValue(filePath).appendText(".\nExpected was:\n\n").appendText(expectedContent).appendText(
                "\n\n But got:\n\n").appendText(itemContent).appendText(
                "\n\nFirst mismatching line:\n\n").appendValue(
                GeneratedReactionsMatcherBuilder.firstMismatchLineIgnoringWhitespace(itemContent, expectedContent));
            };
            this.mismatch = _function_4;
            return false;
          }
        }
      }
      return true;
    }

    @Override
    public void describeTo(final Description description) {
      description.appendText("a reactions file builder producing this reactions file: \n\n").appendText(
        this.expectedReaction);
    }

    @Override
    protected void describeMismatchSafely(final FluentReactionsFileBuilder item, final Description mismatchDescription) {
      if (this.mismatch!=null) {
        this.mismatch.accept(mismatchDescription);
      }
    }
  }

  private static final URI SYNTHETIC = URI.createHierarchicalURI("synthetic", null, null, new String[] {}, null, null);

  @Inject
  private ParseHelper<ReactionsFile> parseHelper;

  @Inject
  private Provider<IReactionsGenerator> generatorProvider;

  @Inject
  private Provider<InMemoryFileSystemAccess> inMemoryFileSystemAccessProvider;

  @Inject
  private Provider<XtextResourceSet> resourceSetProvider;

  /**
   * Created a matcher for a {@link FluentReactionsFileBuilder}. The matcher
   * checks that the builder builds the given {@code expectedReaction}. It
   * does this in two ways: By comparing the serialized builder result with
   * the {@code expectedReaction}, and by generating Java code for both and
   * comparing that code.
   * 
   * <p>The reaction code is compared ignoring whitespace, the generated Java
   * code is compared character by character.
   */
  public Matcher<? super FluentReactionsFileBuilder> builds(final String expectedReaction) {
    return new GeneratedReactionsMatcherBuilder.GeneratedReactionsMatcher(this, expectedReaction);
  }

  /**
   * Tries to build the provided {@code builder}, without any further checks.
   */
  public void build(final FluentReactionsFileBuilder builder) {
    final IReactionsGenerator generator = this.generatorProvider.get();
    final InMemoryFileSystemAccess fsa = this.inMemoryFileSystemAccessProvider.get();
    generator.useResourceSet(this.resourceSetProvider.get());
    generator.addReactionsFile(builder);
    generator.generate(fsa);
  }

  private String read(final InMemoryFileSystemAccess fsa, final String path) {
    try {
      InputStream _readBinaryFile = fsa.readBinaryFile(path, "");
      InputStreamReader _inputStreamReader = new InputStreamReader(_readBinaryFile);
      return CharStreams.toString(_inputStreamReader);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  private static String withoutWhitespace(final String s) {
    return s.replaceAll("\\s+", "");
  }

  private static boolean equalsIgnoringWhitespace(final String a, final String b) {
    return GeneratedReactionsMatcherBuilder.withoutWhitespace(a).equals(GeneratedReactionsMatcherBuilder.withoutWhitespace(b));
  }

  private static String firstMismatchLineIgnoringWhitespace(final String mismatch, final String reference) {
    final String[] mismatchLines = mismatch.split(System.lineSeparator());
    final String unmatchingLineInMismatch = GeneratedReactionsMatcherBuilder.getFirstLineNotContainedInReferenceText(mismatchLines, reference);
    if ((unmatchingLineInMismatch != null)) {
      return unmatchingLineInMismatch;
    } else {
      final String[] referenceLines = reference.split(System.lineSeparator());
      return GeneratedReactionsMatcherBuilder.getFirstLineNotContainedInReferenceText(referenceLines, mismatch);
    }
  }

  private static String getFirstLineNotContainedInReferenceText(final String[] lines, final String reference) {
    final String referenceWithoutWhitespace = GeneratedReactionsMatcherBuilder.withoutWhitespace(reference);
    final Function1<String, Boolean> _function = (String it) -> {
      boolean _contains = referenceWithoutWhitespace.contains(GeneratedReactionsMatcherBuilder.withoutWhitespace(it));
      return Boolean.valueOf((!_contains));
    };
    return IterableExtensions.<String>findFirst(((Iterable<String>)Conversions.doWrapArray(lines)), _function);
  }
}
